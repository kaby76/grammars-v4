(root (stmtblock (stmtmulti (stmt (createfunctionstmt CREATE FUNCTION (func_name (type_function_name (identifier emp_stamp))) (func_args_with_defaults ( )) RETURNS (func_return (func_type (typename (simpletypename (generictype (type_function_name (unreserved_keyword trigger)))) opt_array_bounds))) (createfunc_opt_list (createfunc_opt_item AS (func_as (sconst (anysconst $emp_stamp$ \n    BEGIN\n        -- Check that empname and salary are given\n        IF NEW.empname IS NULL THEN\n            RAISE EXCEPTION 'empname cannot be null';\n        END IF;\n        IF NEW.salary IS NULL THEN\n            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n        END IF;\n\n        -- Who works for us when she must pay for it?\n        IF NEW.salary < 0 THEN\n            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n        END IF;\n\n        -- Remember who changed the payroll when\n        NEW.last_date := current_timestamp;\n        NEW.last_user := current_user;\n        RETURN NEW;\n    END;\n $emp_stamp$)))) (createfunc_opt_item LANGUAGE (nonreservedword_or_sconst (nonreservedword (identifier plpgsql))))))) ; (stmt (createfunctionstmt CREATE (or_replace_ OR REPLACE) FUNCTION (func_name (type_function_name (identifier process_emp_audit))) (func_args_with_defaults ( )) RETURNS (func_return (func_type (typename (simpletypename (generictype (type_function_name (unreserved_keyword TRIGGER)))) opt_array_bounds))) (createfunc_opt_list (createfunc_opt_item AS (func_as (sconst (anysconst $emp_audit$ \n    BEGIN\n        --\n        -- Create a row in emp_audit to reflect the operation performed on emp,\n        -- make use of the special variable TG_OP to work out the operation.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n            RETURN NEW;\n        END IF;\n        RETURN NULL; -- result is ignored since this is an AFTER trigger\n    END;\n $emp_audit$)))) (createfunc_opt_item LANGUAGE (nonreservedword_or_sconst (nonreservedword (identifier plpgsql))))))) ; (stmt (createtrigstmt CREATE TRIGGER (name (colid (identifier emp_audit))) (triggeractiontime AFTER) (triggerevents (triggeroneevent INSERT) OR (triggeroneevent UPDATE) OR (triggeroneevent DELETE)) ON (qualified_name (colid (identifier emp))) (triggerforspec FOR (triggerforopteach EACH) (triggerfortype ROW)) EXECUTE (function_or_procedure PROCEDURE) (func_name (type_function_name (identifier process_emp_audit))) ( triggerfuncargs ))) ; (stmt (createfunctionstmt CREATE (or_replace_ OR REPLACE) FUNCTION (func_name (type_function_name (identifier update_emp_view))) (func_args_with_defaults ( )) RETURNS (func_return (func_type (typename (simpletypename (generictype (type_function_name (unreserved_keyword TRIGGER)))) opt_array_bounds))) (createfunc_opt_list (createfunc_opt_item AS (func_as (sconst (anysconst $$ \n    BEGIN\n        --\n        -- Perform the required operation on emp, and create a row in emp_audit\n        -- to reflect the change made to emp.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            DELETE FROM emp WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            OLD.last_updated = now();\n            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n            RETURN NEW;\n        END IF;\n    END;\n $$)))) (createfunc_opt_item LANGUAGE (nonreservedword_or_sconst (nonreservedword (identifier plpgsql))))))) ; (stmt (createtrigstmt CREATE TRIGGER (name (colid (identifier emp_audit))) (triggeractiontime INSTEAD OF) (triggerevents (triggeroneevent INSERT) OR (triggeroneevent UPDATE) OR (triggeroneevent DELETE)) ON (qualified_name (colid (identifier emp_view))) (triggerforspec FOR (triggerforopteach EACH) (triggerfortype ROW)) EXECUTE (function_or_procedure PROCEDURE) (func_name (type_function_name (identifier update_emp_view))) ( triggerfuncargs ))) ; (stmt (createfunctionstmt CREATE (or_replace_ OR REPLACE) FUNCTION (func_name (type_function_name (identifier maint_sales_summary_bytime))) (func_args_with_defaults ( )) RETURNS (func_return (func_type (typename (simpletypename (generictype (type_function_name (unreserved_keyword TRIGGER)))) opt_array_bounds))) (createfunc_opt_list (createfunc_opt_item AS (func_as (sconst (anysconst $maint_sales_summary_bytime$ \n    DECLARE\n        delta_time_key          integer;\n        delta_amount_sold       numeric(15,2);\n        delta_units_sold        numeric(12);\n        delta_amount_cost       numeric(15,2);\n    BEGIN\n\n        -- Work out the increment/decrement amount(s).\n        IF (TG_OP = 'DELETE') THEN\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = -1 * OLD.amount_sold;\n            delta_units_sold = -1 * OLD.units_sold;\n            delta_amount_cost = -1 * OLD.amount_cost;\n\n        ELSIF (TG_OP = 'UPDATE') THEN\n\n            -- forbid updates that change the time_key -\n            -- (probably not too onerous, as DELETE + INSERT is how most\n            -- changes will be made).\n            IF ( OLD.time_key != NEW.time_key) THEN\n                RAISE EXCEPTION 'Update of time_key : % -> % not allowed',\n                                                      OLD.time_key, NEW.time_key;\n            END IF;\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n            delta_units_sold = NEW.units_sold - OLD.units_sold;\n            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n\n        ELSIF (TG_OP = 'INSERT') THEN\n\n            delta_time_key = NEW.time_key;\n            delta_amount_sold = NEW.amount_sold;\n            delta_units_sold = NEW.units_sold;\n            delta_amount_cost = NEW.amount_cost;\n\n        END IF;\n\n\n        -- Insert or update the summary row with the new values.\n        <<insert_update>>\n        LOOP\n            UPDATE sales_summary_bytime\n                SET amount_sold = amount_sold + delta_amount_sold,\n                    units_sold = units_sold + delta_units_sold,\n                    amount_cost = amount_cost + delta_amount_cost\n                WHERE time_key = delta_time_key;\n\n            EXIT insert_update WHEN found;\n\n            BEGIN\n                INSERT INTO sales_summary_bytime (\n                            time_key,\n                            amount_sold,\n                            units_sold,\n                            amount_cost)\n                    VALUES (\n                            delta_time_key,\n                            delta_amount_sold,\n                            delta_units_sold,\n                            delta_amount_cost\n                           );\n\n                EXIT insert_update;\n\n            EXCEPTION\n                WHEN UNIQUE_VIOLATION THEN\n                    -- do nothing\n            END;\n        END LOOP insert_update;\n\n        RETURN NULL;\n\n    END;\n $maint_sales_summary_bytime$)))) (createfunc_opt_item LANGUAGE (nonreservedword_or_sconst (nonreservedword (identifier plpgsql))))))) ; (stmt (createtrigstmt CREATE TRIGGER (name (colid (identifier maint_sales_summary_bytime))) (triggeractiontime AFTER) (triggerevents (triggeroneevent INSERT) OR (triggeroneevent UPDATE) OR (triggeroneevent DELETE)) ON (qualified_name (colid (identifier sales_fact))) (triggerforspec FOR (triggerforopteach EACH) (triggerfortype ROW)) EXECUTE (function_or_procedure PROCEDURE) (func_name (type_function_name (identifier maint_sales_summary_bytime))) ( triggerfuncargs ))) ;)) <EOF>)